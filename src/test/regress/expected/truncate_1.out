-- Test basic TRUNCATE functionality.
CREATE TABLE truncate_a (col1 integer primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "truncate_a_pkey" for table "truncate_a"
INSERT INTO truncate_a VALUES (1);
INSERT INTO truncate_a VALUES (2);
SELECT * FROM truncate_a ORDER BY 1;
 col1 
------
    1
    2
(2 rows)

-- Roll truncate back
BEGIN;
TRUNCATE truncate_a;
ROLLBACK;
SELECT * FROM truncate_a ORDER BY 1;
 col1 
------
    1
    2
(2 rows)

-- Commit the truncate this time
BEGIN;
TRUNCATE truncate_a;
COMMIT;
SELECT * FROM truncate_a ORDER BY 1;
 col1 
------
(0 rows)

-- Test foreign-key checks
CREATE TABLE trunc_b (a int REFERENCES truncate_a);
CREATE TABLE trunc_c (a serial PRIMARY KEY);
ERROR:  Postgres-XC does not support SERIAL yet
DETAIL:  The feature is not currently supported
CREATE TABLE trunc_d (a int REFERENCES trunc_c);
ERROR:  relation "trunc_c" does not exist
CREATE TABLE trunc_e (a int REFERENCES truncate_a, b int REFERENCES trunc_c);
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE truncate_a;		-- fail
ERROR:  cannot truncate a table referenced in a foreign key constraint
DETAIL:  Table "trunc_b" references "truncate_a".
HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
TRUNCATE TABLE truncate_a,trunc_b;		-- fail
TRUNCATE TABLE truncate_a,trunc_b,trunc_e;	-- ok
ERROR:  relation "trunc_e" does not exist
TRUNCATE TABLE truncate_a,trunc_e;		-- fail
ERROR:  relation "trunc_e" does not exist
TRUNCATE TABLE trunc_c;		-- fail
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,trunc_d;		-- fail
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,trunc_d,trunc_e;	-- ok
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;	-- fail
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;	-- ok
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE truncate_a RESTRICT; -- fail
ERROR:  cannot truncate a table referenced in a foreign key constraint
DETAIL:  Table "trunc_b" references "truncate_a".
HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
TRUNCATE TABLE truncate_a CASCADE;  -- ok
NOTICE:  truncate cascades to table "trunc_b"
-- circular references
ALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;
ERROR:  relation "trunc_c" does not exist
-- Add some data to verify that truncating actually works ...
INSERT INTO trunc_c VALUES (1);
ERROR:  relation "trunc_c" does not exist
LINE 1: INSERT INTO trunc_c VALUES (1);
                    ^
INSERT INTO truncate_a VALUES (1);
INSERT INTO trunc_b VALUES (1);
INSERT INTO trunc_d VALUES (1);
ERROR:  relation "trunc_d" does not exist
LINE 1: INSERT INTO trunc_d VALUES (1);
                    ^
INSERT INTO trunc_e VALUES (1,1);
ERROR:  relation "trunc_e" does not exist
LINE 1: INSERT INTO trunc_e VALUES (1,1);
                    ^
TRUNCATE TABLE trunc_c;
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,truncate_a;
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
ERROR:  relation "trunc_c" does not exist
TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;
ERROR:  relation "trunc_c" does not exist
-- Verify that truncating did actually work
SELECT * FROM truncate_a
   UNION ALL
 SELECT * FROM trunc_c
   UNION ALL
 SELECT * FROM trunc_b
   UNION ALL
 SELECT * FROM trunc_d;
ERROR:  relation "trunc_c" does not exist
LINE 3:  SELECT * FROM trunc_c
                       ^
SELECT * FROM trunc_e;
ERROR:  relation "trunc_e" does not exist
LINE 1: SELECT * FROM trunc_e;
                      ^
-- Add data again to test TRUNCATE ... CASCADE
INSERT INTO trunc_c VALUES (1);
ERROR:  relation "trunc_c" does not exist
LINE 1: INSERT INTO trunc_c VALUES (1);
                    ^
INSERT INTO truncate_a VALUES (1);
ERROR:  duplicate key value violates unique constraint "truncate_a_pkey"
INSERT INTO trunc_b VALUES (1);
INSERT INTO trunc_d VALUES (1);
ERROR:  relation "trunc_d" does not exist
LINE 1: INSERT INTO trunc_d VALUES (1);
                    ^
INSERT INTO trunc_e VALUES (1,1);
ERROR:  relation "trunc_e" does not exist
LINE 1: INSERT INTO trunc_e VALUES (1,1);
                    ^
TRUNCATE TABLE trunc_c CASCADE;  -- ok
ERROR:  relation "trunc_c" does not exist
SELECT * FROM truncate_a
   UNION ALL
 SELECT * FROM trunc_c
   UNION ALL
 SELECT * FROM trunc_b
   UNION ALL
 SELECT * FROM trunc_d;
ERROR:  relation "trunc_c" does not exist
LINE 3:  SELECT * FROM trunc_c
                       ^
SELECT * FROM trunc_e;
ERROR:  relation "trunc_e" does not exist
LINE 1: SELECT * FROM trunc_e;
                      ^
DROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;
ERROR:  table "trunc_c" does not exist
-- Test TRUNCATE with inheritance
CREATE TABLE trunc_f (col1 integer primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "trunc_f_pkey" for table "trunc_f"
INSERT INTO trunc_f VALUES (1);
INSERT INTO trunc_f VALUES (2);
CREATE TABLE trunc_fa (col2a text) INHERITS (trunc_f);
INSERT INTO trunc_fa VALUES (3, 'three');
CREATE TABLE trunc_fb (col2b int) INHERITS (trunc_f);
INSERT INTO trunc_fb VALUES (4, 444);
CREATE TABLE trunc_faa (col3 text) INHERITS (trunc_fa);
INSERT INTO trunc_faa VALUES (5, 'five', 'FIVE');
BEGIN;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
    3
    4
    5
(5 rows)

TRUNCATE trunc_f;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
(0 rows)

ROLLBACK;
BEGIN;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
    3
    4
    5
(5 rows)

TRUNCATE ONLY trunc_f;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    3
    4
    5
(3 rows)

ROLLBACK;
BEGIN;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
    3
    4
    5
(5 rows)

SELECT * FROM trunc_fa ORDER BY 1, 2;
 col1 | col2a 
------+-------
    3 | three
    5 | five
(2 rows)

SELECT * FROM trunc_faa ORDER BY 1, 2;
 col1 | col2a | col3 
------+-------+------
    5 | five  | FIVE
(1 row)

TRUNCATE ONLY trunc_fb, ONLY trunc_fa;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
    5
(3 rows)

SELECT * FROM trunc_fa ORDER BY 1, 2;
 col1 | col2a 
------+-------
    5 | five
(1 row)

SELECT * FROM trunc_faa ORDER BY 1, 2;
 col1 | col2a | col3 
------+-------+------
    5 | five  | FIVE
(1 row)

ROLLBACK;
BEGIN;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
    3
    4
    5
(5 rows)

SELECT * FROM trunc_fa ORDER BY 1, 2;
 col1 | col2a 
------+-------
    3 | three
    5 | five
(2 rows)

SELECT * FROM trunc_faa ORDER BY 1, 2;
 col1 | col2a | col3 
------+-------+------
    5 | five  | FIVE
(1 row)

TRUNCATE ONLY trunc_fb, trunc_fa;
SELECT * FROM trunc_f ORDER BY 1;
 col1 
------
    1
    2
(2 rows)

SELECT * FROM trunc_fa ORDER BY 1, 2;
 col1 | col2a 
------+-------
(0 rows)

SELECT * FROM trunc_faa ORDER BY 1, 2;
 col1 | col2a | col3 
------+-------+------
(0 rows)

ROLLBACK;
DROP TABLE trunc_f CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table trunc_fa
drop cascades to table trunc_faa
drop cascades to table trunc_fb
-- Test ON TRUNCATE triggers
CREATE TABLE trunc_trigger_test (f1 int, f2 text, f3 text);
CREATE TABLE trunc_trigger_log (tgop text, tglevel text, tgwhen text,
        tgargv text, tgtable name, rowcount bigint);
CREATE FUNCTION trunctrigger() RETURNS trigger as $$
declare c bigint;
begin
    execute 'select count(*) from ' || quote_ident(tg_table_name) into c;
    insert into trunc_trigger_log values
      (TG_OP, TG_LEVEL, TG_WHEN, TG_ARGV[0], tg_table_name, c);
    return null;
end;
$$ LANGUAGE plpgsql;
-- basic before trigger
INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
CREATE TRIGGER t
BEFORE TRUNCATE ON trunc_trigger_test
FOR EACH STATEMENT 
EXECUTE PROCEDURE trunctrigger('before trigger truncate');
ERROR:  Postgres-XC does not support TRIGGER yet
DETAIL:  The feature is not currently supported
SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
 Row count in test table 
-------------------------
                       2
(1 row)

SELECT * FROM trunc_trigger_log;
 tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
------+---------+--------+--------+---------+----------
(0 rows)

TRUNCATE trunc_trigger_test;
SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
 Row count in test table 
-------------------------
                       0
(1 row)

SELECT * FROM trunc_trigger_log;
 tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
------+---------+--------+--------+---------+----------
(0 rows)

DROP TRIGGER t ON trunc_trigger_test;
ERROR:  trigger "t" for table "trunc_trigger_test" does not exist
truncate trunc_trigger_log;
-- same test with an after trigger
INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
CREATE TRIGGER tt
AFTER TRUNCATE ON trunc_trigger_test
FOR EACH STATEMENT 
EXECUTE PROCEDURE trunctrigger('after trigger truncate');
ERROR:  Postgres-XC does not support TRIGGER yet
DETAIL:  The feature is not currently supported
SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
 Row count in test table 
-------------------------
                       2
(1 row)

SELECT * FROM trunc_trigger_log;
 tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
------+---------+--------+--------+---------+----------
(0 rows)

TRUNCATE trunc_trigger_test;
SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
 Row count in test table 
-------------------------
                       0
(1 row)

SELECT * FROM trunc_trigger_log;
 tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
------+---------+--------+--------+---------+----------
(0 rows)

DROP TABLE trunc_trigger_test;
DROP TABLE trunc_trigger_log;
DROP FUNCTION trunctrigger();
-- test TRUNCATE ... RESTART IDENTITY
CREATE SEQUENCE truncate_a_id1 START WITH 33;
CREATE TABLE truncate_a (id serial,
                         id1 integer default nextval('truncate_a_id1'));
ERROR:  Postgres-XC does not support SERIAL yet
DETAIL:  The feature is not currently supported
ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
ERROR:  column "id1" of relation "truncate_a" does not exist
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
SELECT * FROM truncate_a ORDER BY id;
ERROR:  column "id" does not exist
LINE 1: SELECT * FROM truncate_a ORDER BY id;
                                          ^
TRUNCATE truncate_a;
ERROR:  cannot truncate a table referenced in a foreign key constraint
DETAIL:  Table "trunc_b" references "truncate_a".
HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
SELECT * FROM truncate_a ORDER BY id;
ERROR:  column "id" does not exist
LINE 1: SELECT * FROM truncate_a ORDER BY id;
                                          ^
TRUNCATE truncate_a RESTART IDENTITY;
ERROR:  cannot truncate a table referenced in a foreign key constraint
DETAIL:  Table "trunc_b" references "truncate_a".
HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
INSERT INTO truncate_a DEFAULT VALUES;
ERROR:  null value in column "col1" violates not-null constraint
SELECT * FROM truncate_a ORDER BY id;
ERROR:  column "id" does not exist
LINE 1: SELECT * FROM truncate_a ORDER BY id;
                                          ^
DROP TABLE truncate_a;
ERROR:  cannot drop table truncate_a because other objects depend on it
DETAIL:  constraint trunc_b_a_fkey on table trunc_b depends on table truncate_a
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
SELECT nextval('truncate_a_id1'); -- fail, seq should have been dropped
 nextval 
---------
      33
(1 row)

